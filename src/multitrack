#!/usr/bin/env python

############################################################################
# This file is part of Multitrack.                                         #
#                                                                          #
# Copyright (C) 2012 K. Scott Tripp                                        #
#                                                                          #
# AUTHORS:	K. Scott Tripp, <kscott.tripp@gmail.com>                       #
#                                                                          #
# Multitrack is free software: you can redistribute it and/or modify       #
# it under the terms of the GNU General Public License as published by     #
# the Free Software Foundation, either version 3 of the License, or        #
# (at your option) any later version.                                      #
#                                                                          #
# Multitrack is distributed in the hope that it will be useful,            #
# but WITHOUT ANY WARRANTY; without even the implied warranty of           #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
# GNU General Public License for more details.                             #
#                                                                          #
# You should have received a copy of the GNU General Public License        #
# along with Multitrack.  If not, see <http://www.gnu.org/licenses/>.      #
############################################################################

# This script is design to operate in daemon mode (eventually).
# It will always track whatever satellite is overhead.  In the event
# of multiple satellites, it will track whichever pass started first.

import ConfigParser
import subprocess
import os, urllib2, time, calendar

### Parameters ########################
numHours = 24		# interval that this script should be run
startDelay = 5		# minutes before pass starts
#configDir = ".config/multitrack"
configDir = ".config/multitrack"
#######################################


# Check for config file, if it doesn't exist create one from the sample
configDir = os.getenv("HOME") + "/" + configDir
if os.path.exists(configDir + "/multitrack.conf"):
	print "Using config file " + configDir + "/multitrack.conf"
else:
	if os.path.exists(configDir + "/multitrack"):
		print "Copying example config file to " + configDir
		os.system("cp /usr/local/share/multitrack/multitrack.conf " + configDir)
	else:
		os.system("mkdir " + configDir)
		print "Copying example config file to " + configDir
		os.system("cp /usr/local/share/multitrack/multitrack.conf " + configDir)


# Read in satellites to track
conf = ConfigParser.ConfigParser()
conf.read(configDir + "/multitrack.conf")
print conf.sections()
satSet = conf.items("Sats")

# Create Satellite ID arrays
sats = []
satIDs = []
for index in range(0,len(satSet)):
	pair = satSet[index]
	sats.append(str.upper(pair[0]))
	if str.upper(pair[1]) is not "":
		satIDs.append(str.upper(pair[1]))
	else:
		satIDs.append(str.upper(pair[0]))

# Fetch and parse TLE File
os.system("tleupdate -d " + configDir)

for index in range(0, len(sats)):
	sat = sats[index]
	tleMaster = open(configDir + "/" + conf.get("TLE", "tle"), "r")
	tleSingle = open(configDir + "/" + sat + ".txt", "w")

	while True:
		line = tleMaster.readline()
		if line == (satIDs[index] + "\n"):
			tleSingle.write(line)
			tleSingle.write(tleMaster.readline())
			tleSingle.write(tleMaster.readline())
			break
		if len(line) == 0:
			break

	tleSingle.close()
	tleMaster.close()


# Set up time variables
time_t = time.time()
tlocal = time.asctime()

while True:
	status = open(configDir + "/status.txt", 'w')
	status.write("Satellite \t\t elevation\n")

	# Loop through Satellites
	for sat in sats:

		# Call pass prediction
		cmdString =  "satpredict -n"
		#cmdString = cmdString + " -o " + configDir + "/status.txt"
		cmdString = cmdString + " -t " + configDir + "/" + sat + ".txt"
		#print cmdString
		process = subprocess.Popen(cmdString, shell=True, stdout=subprocess.PIPE)

		sat_vector = process.communicate()[0].split(' ')
		statusString = sat + '\t\t' + sat_vector[2] + '\n'
		status.write(statusString)

	status.close()
	time.sleep(1)
