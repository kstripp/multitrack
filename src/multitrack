#!/usr/bin/env python

############################################################################
# This file is part of Multitrack.                                         #
#                                                                          #
# Copyright (C) 2012 K. Scott Tripp                                        #
#                                                                          #
# AUTHORS:	K. Scott Tripp, <kscott.tripp@gmail.com>                       #
#                                                                          #
# Multitrack is free software: you can redistribute it and/or modify       #
# it under the terms of the GNU General Public License as published by     #
# the Free Software Foundation, either version 3 of the License, or        #
# (at your option) any later version.                                      #
#                                                                          #
# Multitrack is distributed in the hope that it will be useful,            #
# but WITHOUT ANY WARRANTY; without even the implied warranty of           #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
# GNU General Public License for more details.                             #
#                                                                          #
# You should have received a copy of the GNU General Public License        #
# along with Multitrack.  If not, see <http://www.gnu.org/licenses/>.      #
############################################################################


# This script is designed to run as a daily cron job.  It updates the
# local TLE database and then schedules passes for each tracked satellite.

import ConfigParser

import os, urllib2, time, calendar

### Parameters ########################
maxPasses = 10
predictionURL_base = "http://gs.engin.umich.edu/predictions2/ANN_ARBOR/"
aos_col = 0
los_col = 2
orbNum_col = 9
numHours = 24		# interval that this script should be run
startDelay = 5		# minutes before pass starts
configDir = ".config/multitrack"
#######################################


# Check for config file, if it doesn't exist create one from the sample
configDir = os.getenv("HOME") + "/" + configDir
if os.path.exists(configDir + "/multitrack.conf"):
	print "Using config file " + configDir + "/multitrack.conf"
else:
	if os.path.exists(configDir + "/multitrack"):
		print "Copying example config file to " + configDir
		os.system("cp /usr/local/share/multitrack/multitrack.conf " + configDir)
	else:
		os.system("mkdir " + configDir)
		print "Copying example config file to " + configDir
		os.system("cp /usr/local/share/multitrack/multitrack.conf " + configDir)


# Read in satellites to track
conf = ConfigParser.ConfigParser()
conf.read(configDir + "/multitrack.conf")
print conf.sections()
satSet = conf.items("Sats")

# Create Satellite ID arrays
sats = []
satIDs = []
for index in range(0,len(satSet)):
	pair = satSet[index]
	sats.append(str.upper(pair[0]))
	if str.upper(pair[1]) is not "":
		satIDs.append(str.upper(pair[1]))
	else:
		satIDs.append(str.upper(pair[0]))

# Fetch and parse TLE File
os.system("tleupdate -d " + configDir)

for index in range(0, len(sats)):
	sat = sats[index]
	tleMaster = open(configDir + "/" + conf.get("TLE", "tle"), "r")
	tleSingle = open(configDir + "/" + sat + ".txt", "w")

	while True:
		line = tleMaster.readline()
		if line == (satIDs[index] + "\n"):
			tleSingle.write(line)
			tleSingle.write(tleMaster.readline())
			tleSingle.write(tleMaster.readline())
			break
		if len(line) == 0:
			break

	tleSingle.close()
	tleMaster.close()


# Set up time variables
time_t = time.time()
tlocal = time.asctime()

# Loop through Satellites
for sat in sats:
	predictionURL=predictionURL_base+sat
	try:
		pred = urllib2.urlopen(predictionURL)
	except urllib2.URLError:
		msg = tlocal + ": URL Error, passes not scheduled"
		print msg
		os.system("echo " + msg + " >> " + configDir + "/errlog.txt")
		quit()
	except urllib2.HTTPError:
		msg = str(tlocal) + ": HTTP Error, passes not scheduled"
		os.system("echo " + msg + " >> " + configDir + "/errlog.txt")
		quit()

	# iterate passes in the next 24 hours
	numPasses = 0
	while numPasses < maxPasses:
		satpass =  pred.readline().split('&')
		passtime = time.strptime(satpass[aos_col] + " UTC", '%Y/%m/%d %H:%M:%S %Z')
		lostime = time.strptime(satpass[los_col] + " UTC", '%Y/%m/%d %H:%M:%S %Z')
		orbitNum = satpass[orbNum_col].split('\n')[0].split(' ')[1]

		# Conver UTC time struct to UNIX
		passtime = calendar.timegm(passtime)
		lostime = calendar.timegm(lostime)

		# Check that pass is within planned interval
		if passtime > time_t + 60*60*numHours:
			break

		# Call pass prediction
		cmdString =  "satpredict -a " + str(passtime) + ' -l ' + str(lostime)
		cmdString = cmdString + " -o " + configDir + "/" + orbitNum + "_AA_" + sat + ".txt"
		cmdString = cmdString + " -t " + configDir + "/" + sat + ".txt"
		#print cmdString
		os.system(cmdString)

		# Convert UNIX time to local time struct
		passtime = time.localtime(passtime)

		# Build Command string
		cmdString = "passTrack.py " + configDir + "/" + orbitNum + "_AA_" + sat + ".txt" 
		timeStr = time.strftime('%R %D', passtime)
		cmdString = 'echo "' + cmdString +  '" | at ' + timeStr

		# Execute String
		#os.system(cmdString)
		#print cmdString

		numPasses += 1

	# clean up
	pred.close()
